<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cây Tình Yêu Của Suzy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600&family=Nunito:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #fff5f5 0%, #fed7e2 100%); font-family: 'Nunito', sans-serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }
        .ui-overlay { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; pointer-events: none; z-index: 10; width: 90%; }
        .handwriting { font-family: 'Dancing Script', cursive; }
        
        /* Hiệu ứng ảnh kỷ niệm */
        #photo-overlay { 
            position: fixed; inset: 0; 
            background: rgba(0, 0, 0, 0); 
            display: flex; align-items: center; justify-content: center; 
            z-index: 100; opacity: 0; pointer-events: none; 
            transition: background 0.5s ease, opacity 0.5s ease;
            backdrop-filter: blur(0px);
        }
        #photo-overlay.active { 
            opacity: 1; pointer-events: auto; 
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
        }
        
        #photo-card { 
            max-width: 90%; width: 400px; background: white; 
            padding: 12px; border-radius: 15px; 
            box-shadow: 0 20px 50px rgba(0,0,0,0.5); 
            transform: scale(0); 
            transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); 
        }
        #photo-overlay.active #photo-card { transform: scale(1); }
        
        #photo-img { width: 100%; height: auto; max-height: 60vh; border-radius: 8px; object-fit: cover; display: block; }
        .back-btn { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: white; padding: 12px 25px; border-radius: 50px; text-decoration: none; color: #f43f5e; font-weight: bold; z-index: 10; border: 1px solid #fecaca; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        
        .loading-spinner { border: 4px solid #f3f3f3; border-top: 4px solid #f43f5e; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; display: none; margin: 10px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="ui-overlay">
        <h1 class="text-3xl text-rose-500 handwriting font-bold">Cây Tình Yêu của Chúng Mình</h1>
        <p class="text-gray-500 text-sm mt-2">Chạm vào lá để xem điều bất ngờ nhé!</p>
    </div>

    <a href="index.html" class="back-btn">← Quay lại</a>

    <div id="canvas-container"></div>

    <div id="photo-overlay">
        <div class="flex flex-col items-center w-full">
            <div id="photo-card" onclick="event.stopPropagation()">
                <div id="spinner" class="loading-spinner"></div>
                <img id="photo-img" src="" alt="Kỷ niệm">
                <p id="photo-desc" class="mt-4 text-center text-rose-600 font-semibold italic text-xl handwriting px-2"></p>
            </div>
            <p class="text-white mt-6 opacity-70 text-sm animate-pulse">Chạm để đóng</p>
        </div>
    </div>

    <script>
        const photos = [
            { url: "jpg1.jpg", backup: "https://picsum.photos/seed/love1/400/600", desc: "Mãi yêu em, Suzy của anh" },
            { url: "jpg2.jpg", backup: "https://picsum.photos/seed/love2/400/600", desc: "Khoảnh khắc mình bên nhau" },
            { url: "jpg3.jpg", backup: "https://picsum.photos/seed/love3/400/600", desc: "Nụ cười em làm anh say đắm" },
            { url: "jpg4.jpg", backup: "https://picsum.photos/seed/love4/400/600", desc: "Cảm ơn em đã luôn ở bên" },
            { url: "jpg5.jpg", backup: "https://picsum.photos/seed/love5/400/600", desc: "Kỷ niệm khó quên" },
            { url: "jpg6.jpg", backup: "https://picsum.photos/seed/love6/400/600", desc: "Dù xa nhau nhưng lòng vẫn gần" },
            { url: "jpg7.jpg", backup: "https://picsum.photos/seed/love7/400/600", desc: "Suzy là điều tuyệt vời nhất" },
            { url: "jpg8.jpg", backup: "https://picsum.photos/seed/love8/400/600", desc: "Hẹn gặp lại em sớm nhất nhé" },
            { url: "jpg9.jpg", backup: "https://picsum.photos/seed/love9/400/600", desc: "Yêu em vô điều kiện" },
            { url: "jpg10.jpg", backup: "https://picsum.photos/seed/love10/400/600", desc: "Trái tim anh chỉ có mỗi em" }
        ];

        let scene, camera, renderer, treeGroup, leaves = [];
        let isDragging = false, previousX = 0, moveDistance = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.2));
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(5, 10, 5);
            scene.add(sun);

            treeGroup = new THREE.Group();
            
            // Thân cây
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.9, 12, 12),
                new THREE.MeshLambertMaterial({ color: 0x4d3423 })
            );
            trunk.position.y = 2;
            treeGroup.add(trunk);

            // Tạo hình trái tim cho lá
            const heart = new THREE.Shape();
            heart.moveTo(5, 5);
            heart.bezierCurveTo(5, 5, 4, 0, 0, 0);
            heart.bezierCurveTo(-6, 0, -6, 7, -6, 7);
            heart.bezierCurveTo(-6, 11, -3, 15, 5, 19);
            heart.bezierCurveTo(12, 15, 16, 11, 16, 7);
            heart.bezierCurveTo(16, 7, 16, 0, 10, 0);
            heart.bezierCurveTo(7, 0, 5, 5, 5, 5);
            const leafGeo = new THREE.ShapeGeometry(heart);

            const colors = [0xf43f5e, 0xfb7185, 0xff85a1, 0xffcad4];
            for (let i = 0; i < 1500; i++) {
                const mat = new THREE.MeshLambertMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)], 
                    side: THREE.DoubleSide 
                });
                const leaf = new THREE.Mesh(leafGeo, mat);
                
                const r = 3 + Math.random() * 6;
                const phi = Math.acos(-1 + (2 * i) / 1500);
                const theta = Math.sqrt(1500 * Math.PI) * phi;

                leaf.position.x = r * Math.sin(phi) * Math.cos(theta);
                leaf.position.y = 9 + r * Math.cos(phi) * 0.8;
                leaf.position.z = r * Math.sin(phi) * Math.sin(theta);
                
                // Lưu vị trí gốc để hiệu ứng
                leaf.userData.originalPos = leaf.position.clone();
                leaf.userData.originalScale = 0.015;

                leaf.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                leaf.scale.set(0.015, 0.015, 0.015);
                
                treeGroup.add(leaf);
                leaves.push(leaf);
            }

            scene.add(treeGroup);
            animate();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            if (!isDragging) treeGroup.rotation.y += 0.002;
            renderer.render(scene, camera);
        }

        function handleStart(x) {
            isDragging = true;
            previousX = x;
            moveDistance = 0;
        }

        function handleMove(x) {
            if (!isDragging) return;
            const deltaX = x - previousX;
            treeGroup.rotation.y += deltaX * 0.008;
            previousX = x;
            moveDistance += Math.abs(deltaX);
        }

        function handleEnd(x, y, isClick) {
            isDragging = false;
            if (isClick && moveDistance < 10) {
                checkIntersection(x, y);
            }
        }

        function checkIntersection(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(leaves);
            
            if (intersects.length > 0) {
                const leaf = intersects[0].object;
                animateLeafSelection(leaf);
            }
        }

        function animateLeafSelection(leaf) {
            // Chặn tương tác khi đang diễn ra hiệu ứng
            isDragging = false;
            
            // Tính toán vị trí trước camera
            const targetPos = new THREE.Vector3(0, 0, 10); 
            targetPos.applyMatrix4(camera.matrixWorld);

            // 1. Phóng to và bay về phía camera
            new TWEEN.Tween(leaf.position)
                .to({ x: 0, y: 8, z: 12 }, 600)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(leaf.scale)
                .to({ x: 0.1, y: 0.1, z: 0.1 }, 600)
                .easing(TWEEN.Easing.Back.Out)
                .onComplete(() => {
                    const index = Math.floor(Math.random() * photos.length);
                    showPhoto(index, leaf);
                })
                .start();
                
            new TWEEN.Tween(leaf.rotation)
                .to({ x: 0, y: Math.PI * 2, z: 0 }, 600)
                .start();
        }

        const overlay = document.getElementById('photo-overlay');
        const img = document.getElementById('photo-img');
        const desc = document.getElementById('photo-desc');
        const spinner = document.getElementById('spinner');
        let currentSelectedLeaf = null;

        function showPhoto(idx, leaf) {
            currentSelectedLeaf = leaf;
            const data = photos[idx];
            spinner.style.display = "block";
            img.style.display = "none";
            
            img.src = data.url;
            img.onerror = () => { img.src = data.backup; };
            img.onload = () => {
                spinner.style.display = "none";
                img.style.display = "block";
            };
            
            desc.innerText = data.desc;
            overlay.classList.add('active');
        }

        overlay.addEventListener('click', () => {
            overlay.classList.remove('active');
            
            if (currentSelectedLeaf) {
                // Đưa lá về vị trí cũ
                new TWEEN.Tween(currentSelectedLeaf.position)
                    .to({ 
                        x: currentSelectedLeaf.userData.originalPos.x, 
                        y: currentSelectedLeaf.userData.originalPos.y, 
                        z: currentSelectedLeaf.userData.originalPos.z 
                    }, 500)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .start();

                new TWEEN.Tween(currentSelectedLeaf.scale)
                    .to({ x: 0.015, y: 0.015, z: 0.015 }, 500)
                    .start();
            }
        });

        // Event Listeners
        window.addEventListener('mousedown', (e) => handleStart(e.clientX));
        window.addEventListener('mousemove', (e) => handleMove(e.clientX));
        window.addEventListener('mouseup', (e) => handleEnd(e.clientX, e.clientY, true));

        window.addEventListener('touchstart', (e) => {
            handleStart(e.touches[0].clientX);
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            handleMove(e.touches[0].clientX);
            if (isDragging) e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            handleEnd(touch.clientX, touch.clientY, true);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>
